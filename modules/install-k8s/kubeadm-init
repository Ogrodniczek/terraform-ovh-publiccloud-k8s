#!/bin/bash -e
if [ "$MASTER_MODE" == "0" ] && [ "$WORKER_MODE" == "0" ]; then
    echo "nothing to be done" >&2
fi

function pubipaddr(){
    if ip route get 1.1.1.1 > /dev/null 2>&1; then
        ip -o route get 1.1.1.1 | sed 's/.*src \([0-9\.]*\) .*/\1/g'
    else
        return 1
    fi
}

# required as kubeadm will make use of binaries such as kubelet
export PATH=$PATH:/opt/k8s/bin

# Prepare etcdctl command
export ETCDCTL_API=3
ETCDCTL_COMMAND="/opt/k8s/bin/etcdctl --cacert $ETCD_CA_FILE --cert $ETCD_CERT_FILE --key $ETCD_KEY_FILE --endpoints $ETCD_ENDPOINTS"

# Try to get pki from etcd, if already generated by a previous run of kubeadm
PKI=$($ETCDCTL_COMMAND get --print-value-only "$PKI_ETCD_KEY")
TOKEN=$($ETCDCTL_COMMAND get --print-value-only $BOOTSTRAP_TOKEN_ETCD_KEY)
CACRT_SHASUM=$($ETCDCTL_COMMAND get --print-value-only $CACRT_SHASUM_ETCD_KEY)

if [ -z "$API_ENDPOINT" ]; then
    JOIN=$($ETCDCTL_COMMAND get --prefix "$MASTERS_ETCD_KEYPREFIX" --print-value-only --limit 1):6443
else
    JOIN="$API_ENDPOINT"
fi

if [ -z "$PKI" ] || [ -z "$TOKEN" ] || [ -z "$CACRT_SHASUM" ]; then
    etcd_keys=missing
else
    etcd_keys=present
fi

# Node is a master
if [ "$MASTER_MODE" == "1" ] && [ "$etcd_keys" == "missing" ]; then
    # we need to generate the pki & token and store it into the etcd

    echo "primary master. kubeadm init" >&2
    # generate kubeadm config
    if [ ! -d /etc/kubernetes/kubeadm ]; then
        mkdir -p /etc/kubernetes/kubeadm
    fi

    # kubeadm init
    /opt/k8s/kubeadm_config.yaml.sh "${API_ENDPOINT:-$(pubipaddr):6443}" > /etc/kubernetes/kubeadm/config.yaml

    if ! /opt/k8s/bin/kubeadm init --config=/etc/kubernetes/kubeadm/config.yaml; then
        echo "primary master kubeadm init failed." >&2
        exit 1
    fi

    echo "Putting token into etcd." >&2
    # tokens are valid 24h. if scaling worker nodes after this delay
    # dont forget to regenerate a valid token before
    $ETCDCTL_COMMAND put $BOOTSTRAP_TOKEN_ETCD_KEY "$(/opt/k8s/bin/kubeadm token list | tail -n1 | awk '{print $1}')"
    echo "Putting pki into etcd." >&2
    $ETCDCTL_COMMAND put "$PKI_ETCD_KEY" "$(cd /etc/kubernetes/pki && tar -cf - * | base64)"

    echo "Putting cacrt sha256sum into etcd." >&2
    cacrtsum=$(openssl x509 -in /etc/kubernetes/pki/ca.crt -noout -pubkey | openssl rsa -pubin -outform DER 2>/dev/null | sha256sum | cut -d' ' -f1)
    $ETCDCTL_COMMAND put "$CACRT_SHASUM_ETCD_KEY" "sha256:$cacrtsum"

    echo "Putting cacrt into etcd." >&2
    $ETCDCTL_COMMAND put "$CACRT_ETCD_KEY" "$(cat /etc/kubernetes/ca.crt | base64)"

    echo "Setting admin user credentials in etcd" >&2
    user=${K8S_ADMIN_SA_USERNAME}
    KUBECTL="/opt/bin/kubectl --kubeconfig /etc/kubernetes/admin.conf"
    $KUBECTL create sa "${user}"
    secret=$($KUBECTL get sa "${user}" -o json | jq -r '.secrets[].name')
    user_token=$($KUBECTL get secret "${secret}" -o json | jq -r '.data["token"]' | base64 -d)
    c=$($KUBECTL config current-context)
    cluster_name=$($KUBECTL config get-contexts $c | awk '{print $3}' | tail -n 1)
    endpoint=$($KUBECTL config view -o jsonpath="{.clusters[?(@.name == \"${cluster_name}\")].cluster.server}")

    echo "Grant cluster admin role to ${user}" >&2
    $KUBECTL create clusterrolebinding "${user}-cluster-admin-binding" --clusterrole=cluster-admin --user="system:serviceaccount:default:${user}"

    echo "Putting admin sa username into etcd." >&2
    $ETCDCTL_COMMAND put "$K8S_ADMIN_SA_USERNAME_ETCD_KEY" "${user}"
    echo "Putting admin sa token username into etcd." >&2
    $ETCDCTL_COMMAND put "$K8S_ADMIN_SA_USER_TOKEN_ETCD_KEY" "${user_token}"
    echo "Putting admin sa cluster name into etcd." >&2
    $ETCDCTL_COMMAND put "$K8S_ADMIN_SA_CLUSTER_NAME_ETCD_KEY" "${cluster_name}"
    echo "Putting admin sa endpoint into etcd." >&2
    $ETCDCTL_COMMAND put "$K8S_ADMIN_SA_ENDPOINT_ETCD_KEY" "${endpoint}"


elif  [ "$etcd_keys" == "present" ]; then
    if [ "$MASTER_MODE" == "1" ]; then
        echo "pki already in etcd. retrieving.." >&2
        mkdir -p /etc/kubernetes/pki
        (cd /etc/kubernetes/pki  && echo -e "$PKI" | base64 -d | tar -xf -)

        # Join the cluster
        echo "Joining the cluster as master on endpoint $API_ENDPOINT" >&2
        /opt/k8s/bin/kubeadm join \
                             --discovery-token-ca-cert-hash "$CACRT_SHASUM" \
                             --token "$TOKEN" \
                             --experimental-control-plane \
                             "$JOIN"
        echo "Registering master into etcd." >&2
        if ip=$(pubipaddr); then
            $ETCDCTL_COMMAND put "${MASTERS_ETCD_KEYPREFIX}/$(hostname)" "$ip"
        else
            echo "WARNING: Couldn't get ip addr & register master node." >&2
        fi
    elif [ "$WORKER_MODE" == "1" ]; then
        echo "Joining the cluster as worker on endpoint $API_ENDPOINT" >&2
        /opt/k8s/bin/kubeadm join \
                             --discovery-token-ca-cert-hash "$CACRT_SHASUM" \
                             --token "$TOKEN" \
                             "$JOIN"
    else
        echo "Neither worker nor master" >&2
    fi
else
    if [ -z "$TOKEN" ]; then
        echo "No bootstrap token found into etcd" >&2
    fi
    if [ -z "$CACRT_SHASUM" ]; then
        echo "No cacrt found into etcd" >&2
    fi
    if [ -z "$PKI" ]; then
        echo "No pki found into etcd" >&2
    fi
    if [ -z "$JOIN" ]; then
        echo "No master registered or no API_ENDOINT specified found into etcd" >&2
    fi
    echo "either etcd hasn't got its keys yet or maybe something went wrong" >&2
    exit 1
fi

if [ "$MASTER_MODE" == "1" ]; then
    echo "Registering master into etcd." >&2
    if ip=$(pubipaddr); then
        $ETCDCTL_COMMAND put "${MASTERS_ETCD_KEYPREFIX}/$(hostname)" "$ip"
    else
        echo "WARNING: Couldn't get ip addr & register master node." >&2
    fi
fi
