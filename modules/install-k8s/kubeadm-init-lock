#!/bin/bash

# kubeadm-init-lock runs kubeadm init/join
# on the master nodes and registers the PKI into ETCD

set -eo pipefail

if [ "$MASTER_MODE" != "1" ]; then
    echo "not a master. should not be called" >&2
    exit 1
fi

# required as kubeadm will make use of binaries such as kubelet
export PATH=$PATH:/opt/k8s/bin

# Prepare etcdctl command
export ETCDCTL_API=3
ETCDCTL_COMMAND="/opt/k8s/bin/etcdctl --cacert $ETCD_CA_FILE --cert $ETCD_CERT_FILE --key $ETCD_KEY_FILE --endpoints $ETCD_ENDPOINTS"

# Try to get pki from etcd, if already generated by a previous run of kubeadm
PKI=$($ETCDCTL_COMMAND get --print-value-only "$PKI_ETCD_KEY")

if [ -z "$BOOTSTRAP_TOKEN" ]; then
    TOKEN=$($ETCDCTL_COMMAND get --print-value-only $BOOTSTRAP_TOKEN_ETCD_KEY)
else
    TOKEN="$BOOTSTRAP_TOKEN"
fi

if [ -z "$CACRT_SHA256SUM" ]; then
    CACRT_SHA256SUM=$($ETCDCTL_COMMAND get --print-value-only $CACRT_SHA256SUM_ETCD_KEY)
else
    CACRT_SHA256SUM="$CACRT_SHA256SUM"
fi

if [ -z "$PKI" ] || [ -z "$TOKEN" ] || [ -z "$CACRT_SHA256SUM" ]; then
    master_keys=missing
else
    master_keys=present
fi

if [ "$master_keys" == "missing" ]; then
    # we need to generate the pki & token and store it into the etcd

    echo "primary master. kubeadm init" >&2

    tmpkubeadm=$(mktemp)
    trap "rm -f $tmpkubeadm" EXIT

    # kubeadm init
    /opt/k8s/bin/kubeadm_config.yaml.sh > "$tmpkubeadm"
    if ! /opt/k8s/bin/kubeadm init --config="$tmpkubeadm"; then
        echo "primary master kubeadm init failed." >&2
        exit 1
    fi

    echo "Putting token into etcd." >&2
    # tokens are valid 24h. if scaling worker nodes after this delay
    # dont forget to regenerate a valid token before
    $ETCDCTL_COMMAND put $BOOTSTRAP_TOKEN_ETCD_KEY "$(/opt/k8s/bin/kubeadm token list | tail -n1 | awk '{print $1}')"
    echo "Putting pki into etcd." >&2
    $ETCDCTL_COMMAND put "$PKI_ETCD_KEY" "$(cd /etc/kubernetes/pki && tar -cf - * | base64)"

    echo "Putting cacrt sha256sum into etcd." >&2
    cacrtsum=$(openssl x509 -in /etc/kubernetes/pki/ca.crt -noout -pubkey | openssl rsa -pubin -outform DER 2>/dev/null | sha256sum | cut -d' ' -f1)
    $ETCDCTL_COMMAND put "$CACRT_SHA256SUM_ETCD_KEY" "sha256:$cacrtsum"
else
    if [ -z "$API_ENDPOINT" ]; then
        masterip=$($ETCDCTL_COMMAND get --prefix "$MASTERS_ETCD_KEYPREFIX" \
                                          --print-value-only --limit 1)
        if [ -z "$masterip" ]; then
            echo "ERROR: no master ip registered and no API_ENDPOINT defined" >&2
            exit 1
        fi
        JOIN="${masterip}:6443"
    else
        JOIN="$API_ENDPOINT"
    fi

    echo "pki already in etcd. retrieving.." >&2
    mkdir -p /etc/kubernetes/pki
    (cd /etc/kubernetes/pki  && echo -e "$PKI" | base64 -d | tar -xf -)

    # Join the cluster
    echo "Joining the cluster as master on endpoint $API_ENDPOINT" >&2
    /opt/k8s/bin/kubeadm join \
                         --discovery-token-ca-cert-hash "$CACRT_SHA256SUM" \
                         --token "$TOKEN" \
                         --experimental-control-plane \
                         "$JOIN"
fi
